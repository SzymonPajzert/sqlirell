-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Grammar.Par where
import Grammar.Abs
import Grammar.Lex
import Grammar.ErrM

}

%name pListQuery ListQuery
%name pProgram Program
%name pQuery Query
%name pListExpression ListExpression
%name pExpression Expression
%name pOpExpr14 OpExpr14
%name pOpExpr13 OpExpr13
%name pOpExpr12 OpExpr12
%name pOpExpr11 OpExpr11
%name pOpExpr10 OpExpr10
%name pOpExpr9 OpExpr9
%name pIs Is
%name pAfterNot AfterNot
%name pOpExpr7 OpExpr7
%name pOpExpr6 OpExpr6
%name pOpExpr5 OpExpr5
%name pOpExpr4 OpExpr4
%name pOpExpr3 OpExpr3
%name pOpExpr2 OpExpr2
%name pOpExpr1 OpExpr1
%name pOpExpr OpExpr
%name pOpExpr8 OpExpr8
%name pPathExpr PathExpr
%name pCaseExpr CaseExpr
%name pCaseExprTail CaseExprTail
%name pListCaseExprBind ListCaseExprBind
%name pCaseExprBind CaseExprBind
%name pQuantExpr QuantExpr
%name pQuaneExpr QuaneExpr
%name pListQuantVariable ListQuantVariable
%name pQuantExprHelp QuantExprHelp
%name pQuantVariable QuantVariable
%name pExprQualifier ExprQualifier
%name pPrimaryExpr1 PrimaryExpr1
%name pPrimaryExpr2 PrimaryExpr2
%name pPrimaryExpr PrimaryExpr
%name pLiteral Literal
%name pStringLiteral StringLiteral
%name pIntegerLiteral IntegerLiteral
%name pConstructor Constructor
%name pListFieldBinding ListFieldBinding
%name pFieldBinding FieldBinding
%name pSelectStatement SelectStatement
%name pListUnionedSets ListUnionedSets
%name pSelSetOper SelSetOper
%name pUnionedSets UnionedSets
%name pSelectStatement1 SelectStatement1
%name pSelectBlock SelectBlock
%name pMFromDefVal MFromDefVal
%name pMWhere MWhere
%name pMGroupDefValHaving MGroupDefValHaving
%name pMDefVal MDefVal
%name pSelClause SelClause
%name pSelRegOrVal SelRegOrVal
%name pMTypeSelClause MTypeSelClause
%name pListProjection ListProjection
%name pSelReg SelReg
%name pSelValType SelValType
%name pSelVal SelVal
%name pProjection Projection
%name pMAsIdentifier MAsIdentifier
%name pMAs MAs
%name pListFromTerm ListFromTerm
%name pFromClause FromClause
%name pListFromTermJoin ListFromTermJoin
%name pFromTerm FromTerm
%name pFromTermJoin FromTermJoin
%name pJoinOrUnnest JoinOrUnnest
%name pExprMVarMAt ExprMVarMAt
%name pMMAsVar MMAsVar
%name pUnnestClauseType UnnestClauseType
%name pMAtVar MAtVar
%name pMJoinType MJoinType
%name pJoinType JoinType
%name pListWithElement ListWithElement
%name pWithClause WithClause
%name pMWithClause MWithClause
%name pListLetElement ListLetElement
%name pLetClause LetClause
%name pLetLetClause LetLetClause
%name pLetElement LetElement
%name pWithElement WithElement
%name pWhereClause WhereClause
%name pListExprMVarMAt ListExprMVarMAt
%name pGroupbyClause GroupbyClause
%name pMGroup MGroup
%name pMaybeGroupAs MaybeGroupAs
%name pListVarAsRef ListVarAsRef
%name pMaybeVarAsRef MaybeVarAsRef
%name pVarAsRef VarAsRef
%name pHavingClause HavingClause
%name pMHaving MHaving
%name pMOrder MOrder
%name pListExprOrderbyClause ListExprOrderbyClause
%name pOrderBy OrderBy
%name pExprOrderbyClause ExprOrderbyClause
%name pMaybeOrdOrderbyClause MaybeOrdOrderbyClause
%name pMLimitClause MLimitClause
%name pLimitClause LimitClause
%name pMOffsetExpr MOffsetExpr
%name pVariableRef VariableRef
%name pVariable Variable
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!=' { PT _ (TS _ 1) }
  '\"' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '\'' { PT _ (TS _ 4) }
  '(' { PT _ (TS _ 5) }
  ')' { PT _ (TS _ 6) }
  '*' { PT _ (TS _ 7) }
  '+' { PT _ (TS _ 8) }
  ',' { PT _ (TS _ 9) }
  '-' { PT _ (TS _ 10) }
  '.' { PT _ (TS _ 11) }
  '/' { PT _ (TS _ 12) }
  ':' { PT _ (TS _ 13) }
  ';' { PT _ (TS _ 14) }
  '<' { PT _ (TS _ 15) }
  '<=' { PT _ (TS _ 16) }
  '<>' { PT _ (TS _ 17) }
  '=' { PT _ (TS _ 18) }
  '>' { PT _ (TS _ 19) }
  '>=' { PT _ (TS _ 20) }
  '?' { PT _ (TS _ 21) }
  '[' { PT _ (TS _ 22) }
  ']' { PT _ (TS _ 23) }
  '^' { PT _ (TS _ 24) }
  'all' { PT _ (TS _ 25) }
  'and' { PT _ (TS _ 26) }
  'anu' { PT _ (TS _ 27) }
  'as' { PT _ (TS _ 28) }
  'asc' { PT _ (TS _ 29) }
  'at' { PT _ (TS _ 30) }
  'between' { PT _ (TS _ 31) }
  'by' { PT _ (TS _ 32) }
  'case' { PT _ (TS _ 33) }
  'correlate' { PT _ (TS _ 34) }
  'desc' { PT _ (TS _ 35) }
  'distinct' { PT _ (TS _ 36) }
  'element' { PT _ (TS _ 37) }
  'else' { PT _ (TS _ 38) }
  'end' { PT _ (TS _ 39) }
  'every' { PT _ (TS _ 40) }
  'exists' { PT _ (TS _ 41) }
  'false' { PT _ (TS _ 42) }
  'flatten' { PT _ (TS _ 43) }
  'from' { PT _ (TS _ 44) }
  'group' { PT _ (TS _ 45) }
  'having' { PT _ (TS _ 46) }
  'in' { PT _ (TS _ 47) }
  'inner' { PT _ (TS _ 48) }
  'is' { PT _ (TS _ 49) }
  'join' { PT _ (TS _ 50) }
  'left' { PT _ (TS _ 51) }
  'let' { PT _ (TS _ 52) }
  'letting' { PT _ (TS _ 53) }
  'like' { PT _ (TS _ 54) }
  'limit' { PT _ (TS _ 55) }
  'missing' { PT _ (TS _ 56) }
  'not' { PT _ (TS _ 57) }
  'null' { PT _ (TS _ 58) }
  'offset' { PT _ (TS _ 59) }
  'on' { PT _ (TS _ 60) }
  'or' { PT _ (TS _ 61) }
  'order' { PT _ (TS _ 62) }
  'outer' { PT _ (TS _ 63) }
  'raw' { PT _ (TS _ 64) }
  'satisfies' { PT _ (TS _ 65) }
  'select' { PT _ (TS _ 66) }
  'some' { PT _ (TS _ 67) }
  'then' { PT _ (TS _ 68) }
  'true' { PT _ (TS _ 69) }
  'union' { PT _ (TS _ 70) }
  'unknown' { PT _ (TS _ 71) }
  'unnest' { PT _ (TS _ 72) }
  'value' { PT _ (TS _ 73) }
  'when' { PT _ (TS _ 74) }
  'where' { PT _ (TS _ 75) }
  'with' { PT _ (TS _ 76) }
  '{' { PT _ (TS _ 77) }
  '||' { PT _ (TS _ 78) }
  '}' { PT _ (TS _ 79) }
  '~=' { PT _ (TS _ 80) }

L_integ  { PT _ (TI $$) }
L_Identifier { PT _ (T_Identifier $$) }
L_DelimIdent { PT _ (T_DelimIdent $$) }
L_DoubleString { PT _ (T_DoubleString $$) }
L_SingleString { PT _ (T_SingleString $$) }
L_FloatNum { PT _ (T_FloatNum $$) }
L_DoubleNum { PT _ (T_DoubleNum $$) }
L_OpenSet { PT _ (T_OpenSet $$) }
L_CloseSet { PT _ (T_CloseSet $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Identifier    :: { Identifier} : L_Identifier { Identifier ($1)}
DelimIdent    :: { DelimIdent} : L_DelimIdent { DelimIdent ($1)}
DoubleString    :: { DoubleString} : L_DoubleString { DoubleString ($1)}
SingleString    :: { SingleString} : L_SingleString { SingleString ($1)}
FloatNum    :: { FloatNum} : L_FloatNum { FloatNum ($1)}
DoubleNum    :: { DoubleNum} : L_DoubleNum { DoubleNum ($1)}
OpenSet    :: { OpenSet} : L_OpenSet { OpenSet ($1)}
CloseSet    :: { CloseSet} : L_CloseSet { CloseSet ($1)}

ListQuery :: { [Query] }
ListQuery : {- empty -} { [] }
          | ListQuery Query ';' { flip (:) $1 $2 }
Program :: { Program }
Program : ListQuery { Grammar.Abs.Prog (reverse $1) }
Query :: { Query }
Query : Expression { Grammar.Abs.ExpQuer $1 }
      | SelectStatement { Grammar.Abs.SelQuer $1 }
ListExpression :: { [Expression] }
ListExpression : {- empty -} { [] }
               | Expression { (:[]) $1 }
               | Expression ',' ListExpression { (:) $1 $3 }
Expression :: { Expression }
Expression : OpExpr { Grammar.Abs.OperExpr $1 }
           | CaseExpr { Grammar.Abs.CaseExpr $1 }
           | QuantExpr { Grammar.Abs.QuanExpr $1 }
OpExpr14 :: { OpExpr }
OpExpr14 : PathExpr { Grammar.Abs.PathOpExpr $1 }
         | '(' OpExpr ')' { $2 }
OpExpr13 :: { OpExpr }
OpExpr13 : 'exists' OpExpr14 { Grammar.Abs.ExistsOpExpr $2 }
         | OpExpr14 { $1 }
OpExpr12 :: { OpExpr }
OpExpr12 : OpExpr13 '^' OpExpr12 { Grammar.Abs.ExponeOpExpr $1 $3 }
         | OpExpr13 { $1 }
OpExpr11 :: { OpExpr }
OpExpr11 : OpExpr11 '*' OpExpr12 { Grammar.Abs.MultipOpExpr $1 $3 }
         | OpExpr11 '/' OpExpr12 { Grammar.Abs.DivisiOpExpr $1 $3 }
         | OpExpr11 '%' OpExpr12 { Grammar.Abs.ModuloOpExpr $1 $3 }
         | OpExpr12 { $1 }
OpExpr10 :: { OpExpr }
OpExpr10 : OpExpr10 '+' OpExpr11 { Grammar.Abs.AdditiOpExpr $1 $3 }
         | OpExpr10 '-' OpExpr11 { Grammar.Abs.SubstrOpExpr $1 $3 }
         | OpExpr11 { $1 }
OpExpr9 :: { OpExpr }
OpExpr9 : '-' OpExpr11 { Grammar.Abs.NegationExpr $2 }
        | '+' OpExpr11 { Grammar.Abs.PositiveExpr $2 }
        | OpExpr9 '||' OpExpr10 { Grammar.Abs.ConcatOpExpr $1 $3 }
        | OpExpr10 { $1 }
Is :: { Is }
Is : 'is' { Grammar.Abs.YIs } | 'is' 'not' { Grammar.Abs.NIs }
AfterNot :: { AfterNot }
AfterNot : 'between' OpExpr6 'and' OpExpr6 { Grammar.Abs.BtwnAfterNot $2 $4 }
         | 'like' OpExpr4 { Grammar.Abs.LikeAfterNot $2 }
         | 'in' OpExpr4 { Grammar.Abs.IsInAfterNot $2 }
OpExpr7 :: { OpExpr }
OpExpr7 : OpExpr8 Is 'null' { Grammar.Abs.IsNullOpExpr $1 $2 }
        | OpExpr8 Is 'missing' { Grammar.Abs.IsMissOpExpr $1 $2 }
        | OpExpr8 { $1 }
OpExpr6 :: { OpExpr }
OpExpr6 : OpExpr8 Is 'unknown' { Grammar.Abs.IsUnknOpExpr $1 $2 }
        | OpExpr7 { $1 }
OpExpr5 :: { OpExpr }
OpExpr5 : OpExpr6 'between' OpExpr6 'and' OpExpr6 { Grammar.Abs.IsBtwnOpExpr $1 $3 $5 }
        | OpExpr6 'not' AfterNot { Grammar.Abs.NoAfteOpExpr $1 $3 }
        | OpExpr6 { $1 }
OpExpr4 :: { OpExpr }
OpExpr4 : OpExpr5 '=' OpExpr5 { Grammar.Abs.IsEquaOpExpr $1 $3 }
        | OpExpr5 '~=' OpExpr5 { Grammar.Abs.NoEquaOpExpr $1 $3 }
        | OpExpr5 '!=' OpExpr5 { Grammar.Abs.NoEquaOpExpr $1 $3 }
        | OpExpr5 '<>' OpExpr5 { Grammar.Abs.NoEquaOpExpr $1 $3 }
        | OpExpr5 '>' OpExpr5 { Grammar.Abs.GraterOpExpr $1 $3 }
        | OpExpr5 '>=' OpExpr5 { Grammar.Abs.GrOrEqOpExpr $1 $3 }
        | OpExpr5 '<' OpExpr5 { Grammar.Abs.SmalerOpExpr $1 $3 }
        | OpExpr5 '<=' OpExpr5 { Grammar.Abs.SmOrEqOpExpr $1 $3 }
        | OpExpr5 { $1 }
OpExpr3 :: { OpExpr }
OpExpr3 : OpExpr4 'like' OpExpr4 { Grammar.Abs.IsLikeOpExpr $1 $3 }
        | OpExpr4 'in' OpExpr4 { Grammar.Abs.IsIn__OpExpr $1 $3 }
        | OpExpr4 { $1 }
OpExpr2 :: { OpExpr }
OpExpr2 : 'not' OpExpr3 { Grammar.Abs.NegatiOpExp $2 }
        | OpExpr3 { $1 }
OpExpr1 :: { OpExpr }
OpExpr1 : OpExpr1 'and' OpExpr2 { Grammar.Abs.ConiunOpExp $1 $3 }
        | OpExpr2 { $1 }
OpExpr :: { OpExpr }
OpExpr : OpExpr 'or' OpExpr1 { Grammar.Abs.AlternOpExp $1 $3 }
       | OpExpr1 { $1 }
OpExpr8 :: { OpExpr }
OpExpr8 : OpExpr9 { $1 }
PathExpr :: { PathExpr }
PathExpr : PrimaryExpr { Grammar.Abs.PrimaPathExp $1 }
         | PathExpr '.' VariableRef { Grammar.Abs.FieldPathExp $1 $3 }
         | PathExpr '[' '?' ']' { Grammar.Abs.INullPathExp $1 }
         | PathExpr '[' Expression ']' { Grammar.Abs.IExprPathExp $1 $3 }
CaseExpr :: { CaseExpr }
CaseExpr : 'case' Expression CaseExprTail { Grammar.Abs.SimpleCaseExpr $2 $3 }
         | 'case' CaseExprTail { Grammar.Abs.SearchCaseExpr $2 }
CaseExprTail :: { CaseExprTail }
CaseExprTail : ListCaseExprBind 'end' { Grammar.Abs.NoElseCaseTail $1 }
             | ListCaseExprBind 'else' Expression 'end' { Grammar.Abs.IsElseCaseTail $1 $3 }
ListCaseExprBind :: { [CaseExprBind] }
ListCaseExprBind : CaseExprBind { (:[]) $1 }
                 | CaseExprBind ListCaseExprBind { (:) $1 $2 }
CaseExprBind :: { CaseExprBind }
CaseExprBind : 'when' Expression 'then' Expression { Grammar.Abs.CaseExprBind $2 $4 }
QuantExpr :: { QuantExpr }
QuantExpr : QuantExprHelp 'end' { Grammar.Abs.IsEndQuantExpr $1 }
QuaneExpr :: { QuaneExpr }
QuaneExpr : QuantExprHelp { Grammar.Abs.NoEndQuentExpr $1 }
ListQuantVariable :: { [QuantVariable] }
ListQuantVariable : QuantVariable { (:[]) $1 }
                  | QuantVariable ',' ListQuantVariable { (:) $1 $3 }
QuantExprHelp :: { QuantExprHelp }
QuantExprHelp : ExprQualifier ListQuantVariable 'satisfies' Expression { Grammar.Abs.QuantExprHelp $1 $2 $4 }
QuantVariable :: { QuantVariable }
QuantVariable : VariableRef 'in' Expression { Grammar.Abs.QuantVariable $1 $3 }
ExprQualifier :: { ExprQualifier }
ExprQualifier : 'some' { Grammar.Abs.SomeExprQual }
              | 'anu' { Grammar.Abs.SomeExprQual }
              | 'every' { Grammar.Abs.EveryExprQuar }
PrimaryExpr1 :: { PrimaryExpr }
PrimaryExpr1 : Literal { Grammar.Abs.LiteralPrimaryExpr $1 }
             | VariableRef { Grammar.Abs.VariablPrimaryExpr $1 }
             | Constructor { Grammar.Abs.ConstruPrimaryExpr $1 }
             | PrimaryExpr2 { $1 }
PrimaryExpr2 :: { PrimaryExpr }
PrimaryExpr2 : SelectStatement1 { Grammar.Abs.SubquerPrimaryExpr $1 }
PrimaryExpr :: { PrimaryExpr }
PrimaryExpr : PathExpr '(' ListExpression ')' { Grammar.Abs.FunCallPrimaryExpr $1 $3 }
            | PrimaryExpr1 { $1 }
Literal :: { Literal }
Literal : DoubleString { Grammar.Abs.DStringLiteral $1 }
        | SingleString { Grammar.Abs.SStringLiteral $1 }
        | Integer { Grammar.Abs.IntegeLiteral $1 }
        | FloatNum { Grammar.Abs.FloatiLiteral $1 }
        | DoubleNum { Grammar.Abs.DoubleLiteral $1 }
        | 'null' { Grammar.Abs.NullLiteral }
        | 'missing' { Grammar.Abs.MissingLiteral }
        | 'true' { Grammar.Abs.TrueLiteral }
        | 'false' { Grammar.Abs.FalseLiteral }
StringLiteral :: { StringLiteral }
StringLiteral : '\"' Identifier '\"' { Grammar.Abs.DoubleQuoteString $2 }
              | '\'' Identifier '\'' { Grammar.Abs.SingleQuoteString $2 }
IntegerLiteral :: { IntegerLiteral }
IntegerLiteral : Integer { Grammar.Abs.IntegerLiteral $1 }
Constructor :: { Constructor }
Constructor : '[' ListExpression ']' { Grammar.Abs.ArrayConstr $2 }
            | OpenSet ListExpression CloseSet { Grammar.Abs.MultisetConst $1 $2 $3 }
            | '{' ListFieldBinding '}' { Grammar.Abs.ObjectConstr $2 }
ListFieldBinding :: { [FieldBinding] }
ListFieldBinding : {- empty -} { [] }
                 | FieldBinding { (:[]) $1 }
                 | FieldBinding ',' ListFieldBinding { (:) $1 $3 }
FieldBinding :: { FieldBinding }
FieldBinding : Expression ':' Expression { Grammar.Abs.FieldBinding $1 $3 }
SelectStatement :: { SelectStatement }
SelectStatement : MWithClause SelSetOper MOrder MLimitClause { Grammar.Abs.SelectStmt $1 $2 $3 $4 }
ListUnionedSets :: { [UnionedSets] }
ListUnionedSets : {- empty -} { [] }
                | ListUnionedSets UnionedSets { flip (:) $1 $2 }
SelSetOper :: { SelSetOper }
SelSetOper : SelectBlock ListUnionedSets { Grammar.Abs.SelSetOper $1 (reverse $2) }
UnionedSets :: { UnionedSets }
UnionedSets : 'union' 'all' SelectBlock { Grammar.Abs.SelBlockUnionedSets $3 }
            | 'union' 'all' SelectStatement1 { Grammar.Abs.SubqueryUnionedSets $3 }
SelectStatement1 :: { SelectStatement }
SelectStatement1 : '(' SelectStatement ')' { $2 }
SelectBlock :: { SelectBlock }
SelectBlock : SelClause MFromDefVal MWhere MGroup MOrder MDefVal MHaving { Grammar.Abs.FirstSelBlock $1 $2 $3 $4 $5 $6 $7 }
            | FromClause MDefVal MWhere MGroup MOrder MDefVal MHaving SelClause { Grammar.Abs.SeconSelBlock $1 $2 $3 $4 $5 $6 $7 $8 }
MFromDefVal :: { MFromDefVal }
MFromDefVal : FromClause MDefVal { Grammar.Abs.IsMFromDefVal $1 $2 }
            | {- empty -} { Grammar.Abs.NoMFromDefVal }
MWhere :: { MWhere }
MWhere : WhereClause { Grammar.Abs.IsMWhere $1 }
       | {- empty -} { Grammar.Abs.NoMWhere }
MGroupDefValHaving :: { MGroupDefValHaving }
MGroupDefValHaving : GroupbyClause MDefVal MHaving { Grammar.Abs.IsMGroupDefValHaving $1 $2 $3 }
                   | {- empty -} { Grammar.Abs.NoMGroupDefValHaving }
MDefVal :: { MDefVal }
MDefVal : LetClause { Grammar.Abs.LetMDefVal $1 }
        | WithClause { Grammar.Abs.WitMDefVal $1 }
        | {- empty -} { Grammar.Abs.NonMDefVal }
SelClause :: { SelClause }
SelClause : 'select' MTypeSelClause SelRegOrVal { Grammar.Abs.SelClause $2 $3 }
SelRegOrVal :: { SelRegOrVal }
SelRegOrVal : SelReg { Grammar.Abs.RegSelRegOrVal $1 }
            | SelVal { Grammar.Abs.ValSelRegOrVal $1 }
MTypeSelClause :: { MTypeSelClause }
MTypeSelClause : 'all' { Grammar.Abs.AllMTypeSelClause }
               | 'distinct' { Grammar.Abs.DisMTypeSelClause }
               | {- empty -} { Grammar.Abs.NonMTypeSelClause }
ListProjection :: { [Projection] }
ListProjection : Projection { (:[]) $1 }
               | Projection ',' ListProjection { (:) $1 $3 }
SelReg :: { SelReg }
SelReg : ListProjection { Grammar.Abs.SelReg $1 }
SelValType :: { SelValType }
SelValType : 'value' { Grammar.Abs.ValueSelValType }
           | 'element' { Grammar.Abs.ElemtSelValType }
           | 'raw' { Grammar.Abs.Raw__SelValType }
SelVal :: { SelVal }
SelVal : SelValType Expression { Grammar.Abs.SelVal $1 $2 }
Projection :: { Projection }
Projection : '*' { Grammar.Abs.AllProjection }
           | Expression MAsIdentifier { Grammar.Abs.ExpProjection $1 $2 }
MAsIdentifier :: { MAsIdentifier }
MAsIdentifier : {- empty -} { Grammar.Abs.NoMAsIdent }
              | MAs Identifier { Grammar.Abs.IsMAsIdent $1 $2 }
MAs :: { MAs }
MAs : {- empty -} { Grammar.Abs.NoMAs }
    | 'as' { Grammar.Abs.IsMAs }
ListFromTerm :: { [FromTerm] }
ListFromTerm : FromTerm { (:[]) $1 }
             | FromTerm ',' ListFromTerm { (:) $1 $3 }
FromClause :: { FromClause }
FromClause : 'from' ListFromTerm { Grammar.Abs.FromClause $2 }
ListFromTermJoin :: { [FromTermJoin] }
ListFromTermJoin : {- empty -} { [] }
                 | ListFromTermJoin FromTermJoin { flip (:) $1 $2 }
FromTerm :: { FromTerm }
FromTerm : ExprMVarMAt ListFromTermJoin { Grammar.Abs.FromTerm $1 (reverse $2) }
FromTermJoin :: { FromTermJoin }
FromTermJoin : MJoinType JoinOrUnnest { Grammar.Abs.FromTermJoin $1 $2 }
JoinOrUnnest :: { JoinOrUnnest }
JoinOrUnnest : 'join' ExprMVarMAt 'on' Expression { Grammar.Abs.JoinJoinOrUnnest $2 $4 }
             | UnnestClauseType Expression MAs Variable MAtVar { Grammar.Abs.UnnrJoinOrUnnest $1 $2 $3 $4 $5 }
ExprMVarMAt :: { ExprMVarMAt }
ExprMVarMAt : Expression MMAsVar MAtVar { Grammar.Abs.ExprMVar $1 $2 $3 }
MMAsVar :: { MMAsVar }
MMAsVar : {- empty -} { Grammar.Abs.NoMMAsVar }
        | MAs Variable { Grammar.Abs.IsMMAsVar $1 $2 }
UnnestClauseType :: { UnnestClauseType }
UnnestClauseType : 'unnest' { Grammar.Abs.UnnestUnnestClauseType }
                 | 'correlate' { Grammar.Abs.CorrelUnnestClauseType }
                 | 'flatten' { Grammar.Abs.FlatteUnnestClauseType }
MAtVar :: { MAtVar }
MAtVar : 'at' Variable { Grammar.Abs.IsMAtVar $2 }
       | {- empty -} { Grammar.Abs.NoMAtVar }
MJoinType :: { MJoinType }
MJoinType : JoinType { Grammar.Abs.IsMJoinType $1 }
          | {- empty -} { Grammar.Abs.NoMJoinType }
JoinType :: { JoinType }
JoinType : 'inner' { Grammar.Abs.InnerJoinType }
         | 'left' { Grammar.Abs.LeftNJoinType }
         | 'left' 'outer' { Grammar.Abs.LeftIJoinType }
ListWithElement :: { [WithElement] }
ListWithElement : WithElement { (:[]) $1 }
                | WithElement ',' ListWithElement { (:) $1 $3 }
WithClause :: { WithClause }
WithClause : 'with' ListWithElement { Grammar.Abs.WithClause $2 }
MWithClause :: { MWithClause }
MWithClause : WithClause { Grammar.Abs.IsMWithClause $1 }
            | {- empty -} { Grammar.Abs.NoMWithClause }
ListLetElement :: { [LetElement] }
ListLetElement : LetElement { (:[]) $1 }
               | LetElement ',' ListLetElement { (:) $1 $3 }
LetClause :: { LetClause }
LetClause : LetLetClause ListLetElement { Grammar.Abs.LetClause $1 $2 }
LetLetClause :: { LetLetClause }
LetLetClause : 'let' { Grammar.Abs.FirstLetLetClause }
             | 'letting' { Grammar.Abs.SeconLetLetClause }
LetElement :: { LetElement }
LetElement : Variable '=' Expression { Grammar.Abs.LetElement $1 $3 }
WithElement :: { WithElement }
WithElement : Variable 'as' Expression { Grammar.Abs.WithElement $1 $3 }
WhereClause :: { WhereClause }
WhereClause : 'where' Expression { Grammar.Abs.WhereClause $2 }
ListExprMVarMAt :: { [ExprMVarMAt] }
ListExprMVarMAt : ExprMVarMAt { (:[]) $1 }
                | ExprMVarMAt ',' ListExprMVarMAt { (:) $1 $3 }
GroupbyClause :: { GroupbyClause }
GroupbyClause : 'group' 'by' ListExprMVarMAt MaybeGroupAs { Grammar.Abs.GroupbyClause $3 $4 }
MGroup :: { MGroup }
MGroup : GroupbyClause { Grammar.Abs.IsMGroup $1 }
       | {- empty -} { Grammar.Abs.NoMGroup }
MaybeGroupAs :: { MaybeGroupAs }
MaybeGroupAs : 'group' 'as' Variable MaybeVarAsRef { Grammar.Abs.IsMaybeGroupAs $3 $4 }
             | {- empty -} { Grammar.Abs.NoMaybeGroupAs }
ListVarAsRef :: { [VarAsRef] }
ListVarAsRef : VarAsRef { (:[]) $1 }
             | VarAsRef ',' ListVarAsRef { (:) $1 $3 }
MaybeVarAsRef :: { MaybeVarAsRef }
MaybeVarAsRef : '(' ListVarAsRef ')' { Grammar.Abs.IsMaybeVarAsRef $2 }
              | {- empty -} { Grammar.Abs.NoMaybeVarAsRef }
VarAsRef :: { VarAsRef }
VarAsRef : Variable 'as' VariableRef { Grammar.Abs.VarAsRef $1 $3 }
HavingClause :: { HavingClause }
HavingClause : 'having' Expression { Grammar.Abs.HavingClause $2 }
MHaving :: { MHaving }
MHaving : HavingClause { Grammar.Abs.IsMHaving $1 }
        | {- empty -} { Grammar.Abs.NoMHaving }
MOrder :: { MOrder }
MOrder : OrderBy { Grammar.Abs.IsMOrder $1 }
       | {- empty -} { Grammar.Abs.NoMOrder }
ListExprOrderbyClause :: { [ExprOrderbyClause] }
ListExprOrderbyClause : ExprOrderbyClause { (:[]) $1 }
                      | ExprOrderbyClause ',' ListExprOrderbyClause { (:) $1 $3 }
OrderBy :: { OrderBy }
OrderBy : 'order' 'by' ListExprOrderbyClause { Grammar.Abs.OrderBy $3 }
ExprOrderbyClause :: { ExprOrderbyClause }
ExprOrderbyClause : Expression MaybeOrdOrderbyClause { Grammar.Abs.ExprOrderByClause $1 $2 }
MaybeOrdOrderbyClause :: { MaybeOrdOrderbyClause }
MaybeOrdOrderbyClause : 'asc' { Grammar.Abs.AscOrdClause }
                      | 'desc' { Grammar.Abs.DesOrdClause }
                      | {- empty -} { Grammar.Abs.NonOrdClause }
MLimitClause :: { MLimitClause }
MLimitClause : LimitClause { Grammar.Abs.IsMLimitClause $1 }
             | {- empty -} { Grammar.Abs.NoMLimitClause }
LimitClause :: { LimitClause }
LimitClause : 'limit' Expression MOffsetExpr { Grammar.Abs.LimitClause $2 $3 }
MOffsetExpr :: { MOffsetExpr }
MOffsetExpr : 'offset' Expression { Grammar.Abs.IsMOffsetExpr $2 }
            | {- empty -} { Grammar.Abs.NoMOffsetExpr }
VariableRef :: { VariableRef }
VariableRef : Identifier { Grammar.Abs.VariableRef $1 }
            | DelimIdent { Grammar.Abs.QualifieRef $1 }
Variable :: { Variable }
Variable : Identifier { Grammar.Abs.Variable $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

